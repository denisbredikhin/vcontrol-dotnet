# Copilot Instructions for This Workspace

## Общие принципы
- Репозиторий изначально пустой; структуру создаём **по шагам** по запросам пользователя.
- Не строить всю систему целиком, пока пользователь явно не попросит.
- Все объяснения и обсуждение — **на русском**,
  весь код, имена файлов/папок, Docker‑конфигурация, идентификаторы — **на английском**.

## Цель проекта
- Организовать взаимодействие с котлом Viessmann через Optolink (USB) с помощью `vcontrold`.
- Далее планируется добавить .NET 10‑сервисы и, возможно, интеграцию с MQTT / Home Assistant.
- Проект развивается итеративно: каждая новая функция начинается с явного шага пользователя (например, "start step 1").

## Поведение AI‑агента
- При запросах вида "start step X" агент должен:
  - определить минимально необходимую структуру директорий и файлов;
  - предложить **самый простой рабочий** вариант реализации;
  - сгенерировать **полное содержимое** новых файлов (а не фрагменты);
  - если файлы нельзя создать автоматически, коротко объяснить, как сделать это вручную;
  - обязательно описать, как собирать/запускать/тестировать созданный артефакт (команды для PowerShell на Windows).
- Использовать документацию `vcontrold` отсюда: 
  - https://github.com/openv/vcontrold
  - https://github.com/openv/openv/wiki/vcontrold.xml

## Архитектурные ориентиры
- Первая стадия: инфраструктура вокруг `vcontrold` (в т.ч. Docker‑образ с запущенным сервером и возможностью ручного доступа к `vclient`/`vcontrol`).
- Следующие стадии: отдельные .NET 10 проекты (например, `src/Vcontrol.Api`, `src/Vcontrol.Worker`), которые будут обращаться к `vcontrold` по сети.
- Предпочтительна **простая, модульная структура**: Docker‑файлы и конфиги в `docker/`, .NET‑код в `src/`, дополнительные инструменты — в отдельных подпапках.

## Docker и vcontrold
- Для работы с `vcontrold` создавать конфигурацию внутри `docker/` (например, `Dockerfile`, `vcontrold.xml`, `vito.xml`, `entrypoint.sh`).
- Образ должен позволять:
  - конфигурировать путь к USB‑устройству через переменную окружения (например, `OPTOLINK_DEVICE`);
  - запускать `vcontrold` как сервис в контейнере;
  - подключаться к уже запущенному контейнеру интерактивно и выполнять команды `vclient`/`vcontrol` вручную.
- Все команды для сборки/запуска контейнеров приводить для PowerShell, например:
  - локальная сборка образа на Windows: `cd docker` затем `docker build -t vcontrol-dev .`;
  - локальный тестовый запуск: `docker run --rm -it --device "COM3" -e OPTOLINK_DEVICE="/dev/ttyUSB0" -p 3002:3002 vcontrol-dev`.
- Поддерживать сценарий "build на одной машине, run на другой":
  - собирать образ локально на Windows;
  - при необходимости переименовывать/тегировать образ под реестр (например, `docker tag vcontrol-dev my-registry.local/vcontrol-dev:latest`);
  - пушить образ в используемый реестр (Docker Hub, private registry на OpenMediaVault и т.п.);
  - на целевой машине (OpenMediaVault/Portainer) подтягивать образ из реестра и запускать его с нужным `--device` и `OPTOLINK_DEVICE`.
 - Для CI/CD использовать GitHub Actions workflow `.github/workflows/docker-publish.yml`,
   который собирает образ из `docker/Dockerfile` и публикует его в GitHub Container Registry
   как `ghcr.io/<owner>/vcontrol-dev:latest` (и дополнительные теги по ветке/коммиту).

## Стиль и практики разработки
- Предпочитать **минимальные рабочие** решения, без лишних зависимостей и усложнений.
- При изменении файлов объяснять только то, что специфично для этого репозитория (особенности `vcontrold`, структура Docker, будущая интеграция .NET).
- Не внедрять новые технологии/фреймворки без явного запроса пользователя.
- При создании .NET‑проектов использовать современный стиль C# (.NET 10), отдельные `README.md` с примерами запуска.

## Взаимодействие с пользователем
- При неясных требованиях задавать уточняющие вопросы, но не навязывать лишних сценариев.
- Не придумывать скрытые требования: делать ровно то, что описано в текущем шаге.
- Если требуется несколько шагов, предлагать простой план, но реализовывать только текущий шаг.